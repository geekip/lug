package http

import (
	"errors"
	"fmt"
	"net/http"
	"regexp"
	"strings"
	"sync"

	lua "github.com/yuin/gopher-lua"
)

type Node struct {
	host      string
	handlers  map[string]Handler
	children  map[string]*Node
	paramName string
	paramNode *Node
	regex     *regexp.Regexp
	mu        sync.RWMutex
	isWild    bool
	isEnd     bool
}

var regexCache sync.Map

// makeRegexp compiles and caches regular expressions to avoid redundant compilation
func makeRegexp(pattern string) *regexp.Regexp {
	if re, ok := regexCache.Load(pattern); ok {
		return re.(*regexp.Regexp)
	}
	re := regexp.MustCompile(`^` + pattern + `$`)
	regexCache.Store(pattern, re)
	return re
}

// newNode creates and initializes a new routing node with empty collections
func newNode() *Node {
	return &Node{
		children: make(map[string]*Node),
		handlers: make(map[string]Handler),
	}
}

// add registers a route handler for the given method and pattern
// Returns error for invalid inputs or route conflicts
func (n *Node) add(method, pattern string, handler Handler) error {
	if method == "" || pattern == "" || handler == nil {
		return errors.New("http server Handle error")
	}

	pat, err := parsePattern(pattern)
	if err != nil {
		return fmt.Errorf("parsing %q: %w", pattern, err)
	}

	n.mu.Lock()
	defer n.mu.Unlock()

	for _, segment := range pat.segments {
		if segment.param {
			if n.paramNode == nil {
				pn := newNode()
				pn.paramName = segment.name
				pn.isWild = segment.wild
				if segment.regexp != "" {
					pn.regex = makeRegexp(segment.regexp)
				}
				n.paramNode = pn
			}
			n = n.paramNode
		} else {
			child, exists := n.children[segment.name]
			if !exists {
				child = newNode()
				n.children[segment.name] = child
			}
			n = child
		}
	}

	if _, exists := n.handlers[method]; exists {
		return fmt.Errorf("method conflict: %s %s", method, pattern)
	}

	n.isEnd = true
	n.host = pat.host
	n.handlers[method] = handler
	return nil
}

// find traverses the routing tree to match URL segments and collect parameters
// Returns matched node or nil if no match found
func (n *Node) find(r *http.Request) (Handler, *lua.LTable, int, error) {
	var errNotFound = errors.New("the requested path is not registered on the server")
	host, method, url := r.Host, r.Method, r.URL.Path

	params := &lua.LTable{}
	segments := strings.Split(url, `/`)

	for i, segment := range segments {

		if segment == "" && (n.paramNode == nil || !n.paramNode.isWild) {
			continue
		}

		// static path
		if child := n.children[segment]; child != nil {
			n = child
			if wild := n.findWild(params, segments, i); wild != nil {
				n = wild
				break
			}
			continue
		}

		// param path
		if pn := n.paramNode; pn != nil {
			n = pn
			if n.regex != nil && !n.regex.MatchString(segment) {
				return nil, nil, http.StatusNotFound, errNotFound
			}

			params.RawSetString(n.paramName, lua.LString(segment))
			if wild := n.findWild(params, segments, i); wild != nil {
				n = wild
				break
			}
			continue
		}
		return nil, nil, http.StatusNotFound, errNotFound
	}

	if n.isEnd {

		if n.host != "" && n.host != host {
			err := fmt.Errorf("host not allowed: requested '%s', allowed '%s'", host, n.host)
			return nil, nil, http.StatusForbidden, err
		}

		handler := n.handlers[method]
		if handler == nil {
			handler = n.handlers[`*`]
		}
		if handler == nil {
			err := fmt.Errorf("the requested HTTP method [%s] is not supported for this path", method)
			return nil, nil, http.StatusInternalServerError, err
		}

		return handler, params, http.StatusOK, nil
	}
	return nil, nil, http.StatusNotFound, errNotFound
}

func (n *Node) findWild(params *lua.LTable, segments []string, index int) *Node {
	nextIndex := index + 1

	if !n.isWild {
		n = n.paramNode
	}

	if n != nil && n.isWild {
		if nextIndex == len(segments) {
			return nil
		}
		n.isEnd = true
		param := strings.Join(segments[nextIndex:], `/`)
		params.RawSetString(n.paramName, lua.LString(param))
		return n
	}

	return nil
}
